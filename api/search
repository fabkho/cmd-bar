[{"id":"content:0.index.md","path":"/","dir":"","title":"Home","description":"","keywords":[],"body":"     cmd-bar.   powerful and flexible web component written in Vue.js.                                                                                                                      What's included      Vue compound components   Just import CmdBar and use all its children via a dot notation.    List virtualization   The list component, uses   useVirtualList | VueUse  under the hood, to render only the visible items.    Keybindings   A useKeyMap composable is provided, to handle keybindings with ease.    Unstyled   No CSS is included. You can style it as you want.    Extensible.   Cause of the way it's built, you can extend it as you want.    Examples.   You can find   multiple  examples of how to use it in the   examples folder ."},{"id":"content:1.introduction:1.getting-started.md","path":"/introduction/getting-started","dir":"introduction","title":"Getting Started","description":"Setting up cmd-bar in you vue/nuxt application is only a couple of steps away.","keywords":["Play online","Setup Vue","Setup Nuxt"],"body":"  Getting Started  Setting up cmd-bar in you vue/nuxt application is only a couple of steps away.  Play online  TODO: setup codesandbox/stackblitz\nYou can start playing with Docus in your browser using Stackblitz:  Play on StackBlitz  Setup Vue   Install   cmd-bar  dependency to your project:      npm   install   cmd-bar     yarn   add   cmd-bar    pnpm add cmd-bar\n   Then you can import the   CmdBar  Compound Component in your project.     import   { CmdBar }   from   'cmd-bar'    <  CmdBar   :groups  =  \"groupedCommands\"  >     <  CmdBar.Dialog  >       <  template #header  >         <  CmdBar.Input placeholder  =  \"search for anything /  >       </  template  >       <  template #content  >         <  CmdBar.List :config  =  \"listConfig\"  >             <  template #  default=  \"{ command }\"  >               <  div class  =  \"leading\"  >                 <  img   :src  =  \"command.leading\"   alt  =  \"icon\"   />                 {{ command.label }}               </  div  >               <  span v  -if=  \"command.shortcut\"   class  =  \"actions\"  >                 <  kbd v  -  for  =  \"shortcut of command.shortcut)\"   :key  =  \"shortcut\"  >                   {{ shortcut }}                 </  kbd  >               </  span  >             </  template  >         </  CmdBar.List  >       </  template  >     </  CmdBar.Dialog  >   </  CmdBar  >  Setup Nuxt   Add   cmd-bar  dependency to your project:      npm   install   cmd-bar     yarn   add   cmd-bar    pnpm add cmd-bar\n   Add it to your modules section in your nuxt.config:     export   default   defineNuxtConfig  ({     modules: [  'cmd-bar'  ],   })  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"},{"id":"content:1.introduction:2.data-structure.md","path":"/introduction/data-structure","dir":"introduction","title":"Data Structure","description":"Commands are represented as an array of Command objects. A Command object must at least have an id and a label property. Here is an example:","keywords":["Define your groups"],"body":"  Data Structure  Commands are represented as an array of   Command  objects. A   Command  object must at least have an   id  and a   label  property. Here is an example:     <  script   setup   lang  =  \"ts\"  >   const   commands  :   Command  []   =   [     {       id:   '1'  ,       label:   'Command 1'  ,     },     {       id:   '2'  ,       label:   'Command 2'  ,     },     {       id:   '3'  ,       label:   'Command 3'  ,     },   ]   </  script  >    <  template  >     <  CmdBar   :groups  =  \"[{key: 'people', commands: 'people'}]\"  >       <  template   #  header  >         <  CmdBar.Input   placeholder  =  \"search fo anything\"   />       </  template  >       <  template   #  content  >         <  CmdBar.List   :config  =  \"listConfig\"  >             {{ command.label }}         </  CmdBar.List  >       </  template  >     </  CmdBar  >   </  template  >  Define your groups  Commands are always grouped. You can define your groups by providing an array of   Group  objects to the   groups  prop. It must at least have a   key  and a   commands  property. Here is an example:     <  script   setup   lang  =  \"ts\"  >   const   groups  :   Group  []   =   [     {       key:   'people'  ,       commands: [         {           id:   '1'  ,           label:   'Command 1'  ,         },         {           id:   '2'  ,           label:   'Command 2'  ,         },         {           id:   '3'  ,           label:   'Command 3'  ,         },       ],     },     {       key:   'places'  ,       commands: [         {           id:   '4'  ,           label:   'Command 4'  ,         },         {           id:   '5'  ,           label:   'Command 5'  ,         },         {           id:   '6'  ,           label:   'Command 6'  ,         },       ],     }   ]   </  script  >    <  template  >   <  CmdBar   :groups  =  \"groups\"  >       <  template   #  header  >         <  CmdBar.Input   placeholder  =  \"search fo anything\"   />       </  template  >       <  template   #  content  >         <  CmdBar.List   :config  =  \"listConfig\"  >           <  template   #  default  =  \"  { command }  \"  >               {{ command.label }}           </  template  >         </  CmdBar.List  >       </  template  >     </  CmdBar  >   </  template  >  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"},{"id":"content:1.introduction:6.roadmap.md","path":"/introduction/roadmap","dir":"introduction","title":"Roadmap","description":"","keywords":[],"body":"  Roadmap"},{"id":"content:2.api:1.components.md","path":"/api/components","dir":"api","title":"Components","description":"Discover every provided component.","keywords":["<CmdBar />","<CmdBar.Dialog />","<CmdBar.Input />","<CmdBar.Filter />","<CmdBar.List />","<CmdBar.Magnet />","<Alert />"],"body":"  Components  Discover every provided component.   <CmdBar />  Is the   main  component of this library. It is used to Provide the data to the other components. It takes the following props:    commands : An array of   Group  objects. (See   Group )   <CmdBar.Dialog />  Uses the HTML   <dialog>  element to display the command bar. It takes the following props:    visible : Whether the command bar is visible or not. (Default:   false )  Inside the   CmdBar.Dialog  component, you can use the following slots:    header : The header of the dialog.   content : The content of the dialog.   footer : The footer of the dialog.   This is completely   optional , you can use your   own modal system . But if you want to use the built-in solution, which handles everything out of the box, you can use this component.   <CmdBar.Input />  Provides an input to search through the commands. It takes the following props:    placeholder : The placeholder of the input. (Default:   Search for anything )   modelValue : The value of the input. (Default:   '' )    debounce : Debounce of the input. (Default:   300 )    fuseOptions : The fuse options of the input. (Default:   { includeMatches: true, keys: ['commands.label'] } )   <CmdBar.Filter />  Built-in solution to filter the commands. It takes the following props:    defaultFilterOption : pre-selected filter option. If a key is provided, which is not in the   commands  array, it will be handled as an \"all\" filter. (Example: )   asCheckbox : Wether it should be possible to select multiple options or not. (Default:   false )   <CmdBar.List />  To ensure great performance and scalability, the   CmdBarList  component uses   useVirtualList  under the hood, to render a virtualized list of commands.\nTo work properly, it needs some configuration passed via the   config  prop. Here is an example:     const   listConfig   =   {     /* The height of a single item, in Pixel. */     itemHeightInPixel: {       actions:   48  ,       users:   48     },     /* The height of the container, as a string with a unit of your choice. */     containerHeight:   '21rem'  ,     /* The height of a group label, in Pixel. */     groupLabelHeightInPixel:   20   }   The   itemHeightInPixel  can be an object, which contains the height of each group. Or it can be a number, which will be applied to all groups.  Inside the   CmdBar.List  component, you can use the following slots:    default : The default slot, which is used to render the items and provides the   command  object. (See   Command )   loading : The loading slot, which is used to render the loading state and provides the currently loading   group object. (See   Group )   <CmdBar.Magnet />  WIP  A quick-actions container where you can drag&drop you most used commands, to access them quickly.\nKeep an eye on the   GitHub repository  for updates.   <Alert />  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"},{"id":"content:2.api:2.composables.md","path":"/api/composables","dir":"api","title":"Composables","description":"Discover the composable functions provided by CmdBar.","keywords":["defineCommands()","useKeymap()"],"body":"  Composables  Discover the composable functions provided by CmdBar.   defineCommands()    defineCommands  ()  provides type safety for your commands. It takes an array of   Command  objects and returns an array of   Command  objects.     import   { defineCommands }   from   'cmd-bar'    return   data.value.users.  map  ((  user  :   Record  <  string  ,   any  >)   =>     defineCommand  ({       id: user.id.  toString  (),       leading:   './src/assets/icons/user_new.svg'  ,       label:   `${  user  .  firstName  } ${  user  .  lastName  }`  ,       action  : ()   =>   {         // Define your action here.       }     })   )    useKeymap()   useKeymap()  let's you define your own key bindings.  You can just pass an object with the following structure:     useKeymap  ({     ArrowLeft: {       action  : ()   =>   console.  log  (  'ArrowLeft'  ),       override:   false   // Explicitly set override to false     },     ArrowRight: {       action  : ()   =>   console.  log  (  'ArrowRight'  ),       override:   true   // default     },   })  Some default key bindings are already defined:    ArrowUp : Select the previous item in the list.   ArrowDown : Select the next item in the list.   Enter : Execute the selected item.   The default settings should   not  be overwritten at this time. I am working on a solution that allows manual selection and execution of a command.   html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"}]