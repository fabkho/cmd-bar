[{"id":"content:0.index.md","path":"/","dir":"","title":"Home","description":"","keywords":[],"body":"     cmd-bar.   powerful and flexible web component written in Vue.js.                                                                                                                      What's included      Vue compound components   Just import CmdBar and use all its children via a dot notation.    List virtualization   The list component, uses   useVirtualList | VueUse  under the hood, to render only the visible items.    Keybindings   A useKeyMap composable is provided, to handle keybindings with ease.    Unstyled   No CSS is included. You can style it as you want.    Extensible.   Cause of the way it's built, you can extend it as you want.    Examples.   You can find   multiple  examples of how to use it in the   examples folder ."},{"id":"content:1.introduction:1.getting-started.md","path":"/introduction/getting-started","dir":"introduction","title":"Getting Started","description":"Setting up cmd-bar in you vue/nuxt application is only a couple of steps away.","keywords":["Play online","Setup Vue"],"body":"  Getting Started  Setting up cmd-bar in you vue/nuxt application is only a couple of steps away.  Play online  TODO: setup codesandbox/stackblitz\nYou can start playing with Docus in your browser using Stackblitz:  Play on StackBlitz  Setup Vue   Install   cmd-bar  dependency to your project:      npm   install   cmd-bar     yarn   add   cmd-bar    pnpm add cmd-bar\n   Then you can import the   CmdBar  Compound Component in your project.     import   { CmdBar }   from   'cmd-bar'    <  CmdBar   :groups  =  \"groupedCommands\"  >     <  CmdBar.Dialog  >       <  template #header  >         <  CmdBar.Input placeholder  =  \"search for anything /  >       </  template  >       <  template #content  >         <  CmdBar.VirtualList :config  =  \"listConfig\"  >             <  template #  default=  \"{ command }\"  >               <  div class  =  \"leading\"  >                 <  img   :src  =  \"command.leading\"   alt  =  \"icon\"   />                 {{ command.label }}               </  div  >               <  span v  -if=  \"command.shortcut\"   class  =  \"actions\"  >                 <  kbd v  -  for  =  \"shortcut of command.shortcut)\"   :key  =  \"shortcut\"  >                   {{ shortcut }}                 </  kbd  >               </  span  >             </  template  >         </  CmdBar.VirtualList  >       </  template  >     </  CmdBar.Dialog  >   </  CmdBar  >  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"},{"id":"content:1.introduction:2.data-structure.md","path":"/introduction/data-structure","dir":"introduction","title":"Data Structure","description":"Commands are represented as an array of Command objects. A Command object must at least have an id,label and action property. Here is an example:","keywords":["Define your groups"],"body":"  Data Structure  Commands are represented as an array of   Command  objects. A   Command  object must at least have an   id ,  label  and   action  property. Here is an example:     <  script   setup   lang  =  \"ts\"  >   const   commands  :   Command  []   =   [     {       id:   '1'  ,       label:   'Command 1'  ,       action  : ()   =>   {         console.  log  (  'Command 1'  )       },     },     {       id:   '2'  ,       label:   'Command 2'  ,       action  : ()   =>   {}     },     {       id:   '3'  ,       label:   'Command 3'  ,       action  : ()   =>   {},     },   ]   </  script  >    <  template  >     <  CmdBar   :groups  =  \"[{key: 'people', commands: 'people'}]\"  >       <  template   #  header  >         <  CmdBar.Input   placeholder  =  \"search fo anything\"   />       </  template  >       <  template   #  content  >         <  CmdBar.VirtualList   :config  =  \"listConfig\"  >             {{ command.label }}         </  CmdBar.VirtualList  >       </  template  >     </  CmdBar  >   </  template  >  Define your groups  Commands are always grouped. You can define your groups by providing an array of   Group  objects to the   groups  prop. It   must  at least have a   key . The   commands  property is   optional  to support asynchronous loading of commands. Here is an example:     <  script   setup   lang  =  \"ts\"  >   const   groups  :   Group  []   =   [     {       key:   'people'  ,       commands: [         {           id:   '1'  ,           label:   'Command 1'  ,         },         {           id:   '2'  ,           label:   'Command 2'  ,         },         {           id:   '3'  ,           label:   'Command 3'  ,         },       ],     },     {       key:   'places'  ,       commands: [         {           id:   '4'  ,           label:   'Command 4'  ,         },         {           id:   '5'  ,           label:   'Command 5'  ,         },         {           id:   '6'  ,           label:   'Command 6'  ,         },       ],     }   ]   </  script  >    <  template  >   <  CmdBar   :groups  =  \"groups\"  >       <  template   #  header  >         <  CmdBar.Input   placeholder  =  \"search fo anything\"   />       </  template  >       <  template   #  content  >         <  CmdBar.VirtualList   :config  =  \"listConfig\"  >           <  template   #  default  =  \"  { command }  \"  >               {{ command.label }}           </  template  >         </  CmdBar.VirtualList  >       </  template  >     </  CmdBar  >   </  template  >  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"},{"id":"content:1.introduction:6.roadmap.md","path":"/introduction/roadmap","dir":"introduction","title":"Roadmap","description":"","keywords":[],"body":"  Roadmap"},{"id":"content:2.api:1.components.md","path":"/api/components","dir":"api","title":"Components","description":"Discover every provided component.","keywords":["<CmdBar />","<CmdBar.Dialog />","<CmdBar.Input />","<CmdBar.Filter />","<CmdBar.VirtualList />","<CmdBar.Magnet />"],"body":"  Components  Discover every provided component.   <CmdBar />  Is the   main  component of this library. It is used to Provide the data to the other components. It takes the following props:    commands : An array of   Group  objects.   <CmdBar.Dialog />  Uses the HTML   <dialog>  element to display the command bar. It takes the following props:    visible : Whether the command bar is visible or not. (Default:   false )  Inside the   CmdBar.Dialog  component, you can use the following slots:    header : The header of the dialog.   content : The content of the dialog.   footer : The footer of the dialog.   This is completely   optional , you can use your   own modal system .   <CmdBar.Input />  Provides an input to search through the commands. It takes the following props:    placeholder : The placeholder of the input. (Default:   Search for anything )    fuse : The fuse options of the input. (Default:   { minMatchCharLength: 2, keys: ['commands.label'] } )  To get the current query, you can use the   @input  event. It will provide the current input string.   <CmdBar.Filter />  Built-in solution to filter the commands. It takes the following props:    filterOptions : An array of   FilterOption  objects.   asCheckbox : Whether it should be possible to select multiple options or not. (Default:   false )  Example:     const   filterOptions   =   [     {       groupKey:   'default'  ,       label:   'All'  ,       visible:   true     },     {       groupKey:   'actions'  ,       label:   'Actions'  ,       visible:   true     },     {       groupKey:   'users'  ,       label:   'Users'  ,       visible:   false     }   ]   As you can see, the   groupKey  is used to filter the commands. If you want to   show all commands , you can use the   default  groupKey.  Use the   visible  property to hide a filter option.   <CmdBar.VirtualList />  To ensure great performance and scalability, the   CmdBarVirtualList  component uses   useVirtualList  under the hood, to render a virtualized list of commands.\nTo work properly, it needs some configuration passed via the   config  prop. Here is an example:     const   listConfig   =   {     /* The height of a single item, in Pixel. */     itemHeightInPixel: {       actions:   48  ,       users:   48     },     /* The height of the container, as a string with a unit of your choice. */     containerHeight:   '21rem'  ,     /* The height of a group label, in Pixel. */     groupLabelHeightInPixel:   20   }   The   itemHeightInPixel  can be an object, which contains the height of each group. Or it can be a number, which will be applied to all groups.  Inside the   CmdBar.List  component, you can use the following slots:    default : The default slot, which is used to render the items and provides the   command  object.   loading : The loading slot, which is used to render the loading state and provides the currently loading   group object.   preview : Can be used to render a preview of the currently selected command. (See   Command )   <CmdBar.Magnet />  WIP  A quick-actions container where you can drag&drop you most used commands, to access them quickly.\nKeep an eye on the   GitHub repository  for updates.  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"},{"id":"content:2.api:2.composables.md","path":"/api/composables","dir":"api","title":"Composables","description":"Discover the composable functions provided by CmdBar.","keywords":["defineCommands()","useCmdBarEvent()","useKeymap()"],"body":"  Composables  Discover the composable functions provided by CmdBar.   defineCommands()    defineCommands  ()  provides type safety for your commands. It takes an array of   Command  objects and returns an array of   Command  objects.     import   { defineCommands }   from   'cmd-bar'    return   data.value.users.  map  ((  user  :   Record  <  string  ,   any  >)   =>     defineCommand  ({       id: user.id.  toString  (),       leading:   './src/assets/icons/user_new.svg'  ,       label:   `${  user  .  firstName  } ${  user  .  lastName  }`  ,       action  : ()   =>   {         // Define your action here.       }     })   )    useCmdBarEvent()   useCmdBarEvent()  let's you listen to the events emitted by CmdBar. Currently, the following events are emitted:    selected : Emitted when a command is selected. It provides the selected command.   clicked : Emitted when a command is clicked. It provides the clicked command.  Example usage:     const   activeCommand   =   ref  <  Command   |   null  >(  null  )    const   {   emitter   }   =   useCmdBarEvent  ()    emitter.  on  (  'selected'  , (  command  )   =>   {     activeCommand.value   =   command   })    Tip:  This is particularly useful when you want to   show a preview  of the selected command. (See   Previes Example )    useKeymap()    useKeymap()  let's you define your own key bindings with ease.   html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"},{"id":"content:2.api:3.styles.md","path":"/api/styles","dir":"api","title":"Styles","description":"The cmd-baris completely unstyled. You can style it to your liking by using the style template provided by the CmdBar component.","keywords":["Style Template"],"body":"  Styles  The   cmd-bar is completely unstyled. You can style it to your liking by using the style template provided by the   CmdBar  component.   It's recommended to start off with the   Basic example  and then style and add features as you wish.  Style Template     .cmd-bar   {     &  __header   {       /* Input styles */       .input   {         /* Placeholder styles */         &  ::placeholder   {           /* Placeholder text styles */         }         /* Leading icon styles */         &  __leading   {           /* Leading icon styles */         }         /* Clear button styles */         &  __clear   {           /* Clear button styles */         }       }        /* Filter styles */       .filter   {         /* Filter chip styles */         &  -chip   {           /* Regular chip styles */         }         /* Selected filter chip styles */         &  -chip--selected   {           /* Selected chip styles */         }       }     }      &  __body   {       /* List container styles */       .list   {         &  __container   {           /* List container styles */         }          /* List items styles */         &  __items   {           /* List items styles */         }          /* Single list item styles */         &  __item   {           /* Single list item styles */         }       }        /* Loading element styles */       .skeleton   {         /* Loading animation or skeleton styles */       }        /* Empty list styles */       .empty   {         /* Styles for an empty list */       }     }      &  __footer   {       /* Footer styles */     }      /* Keyboard shortcut styles */     .kbd   {       /* Keyboard shortcut styles */     }      /* Animations */     /* Define animations if needed */   }  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"},{"id":"content:2.api:4.keybindings.md","path":"/api/keybindings","dir":"api","title":"Keybindings","description":"To make your application more accessible, you can use the useKeymap() composable to define your own key bindings.","keywords":["useKeymap()","Command Shortcut"],"body":"  Keybindings  To make your application more accessible, you can use the   useKeymap()  composable to define your own key bindings.  To   bind a key to a command , you can use the   shortcut  property of the   Command  object.  Some   default  key bindings are already defined:    ArrowUp : Select the previous item in the list.   ArrowDown : Select the next item in the list.   Enter : Execute the selected item.   useKeymap()   useKeymap()  let's you define your own key bindings with ease.  You can just pass an object with the following structure:     useKeymap  ((  nav  )   =>   {     return   [       {         key:   'ArrowRight'  ,         action  : ()   =>   nav.  prev  (),         override:   true  ,         autoRepeat:   true          },       {         key:   'ArrowLeft'  ,         action  : ()   =>   nav.  next  (),         override:   true  ,         autoRepeat:   true       }     ]   })   The properties   override  and   autoRepeat  are optional, and both default to   false .  The composable also gives you access to the   nav  object, which provides the following methods:    prev() : Select the previous item in the list.   next() : Select the next item in the list.   execute() : Execute the selected item.   Command Shortcut  You can also define a shortcut for a command by using the   shortcut  property of the   Command  object.     const   actions   =   [     {       id:   'new-resource'  ,       label:   'Create new Resource'  ,       leading:   './src/assets/icons/create.svg'  ,       action  : ()   =>   alert  (  'New Resource created'  ),       shortcut:   'Ctrl+R'     },     {       id:   'new-service'  ,       label:   'Add new Service'  ,       leading:   './src/assets/icons/service_1.svg'  ,       action  : ()   =>   alert  (  'New Service added'  ),       shortcut:   'Ctrl+S'     },   ]   Keybindings are internally handled by   useMagicKeys | VueUse . If you have any questions about the syntax, please refer to their documentation.  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}"},{"id":"content:examples:1.Basic.md","path":"/examples/basic","dir":"examples","title":"Basic","description":"","keywords":[],"body":""},{"id":"content:examples:2.preview.md","path":"/examples/preview","dir":"examples","title":"Preview","description":"","keywords":[],"body":""}]