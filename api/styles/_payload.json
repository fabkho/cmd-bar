[{"data":1,"prerenderedAt":74},["Reactive",2],{"search-api":3},[4,11,21,29,35,49,58,66],{"id":5,"path":6,"dir":7,"title":8,"description":7,"keywords":9,"body":10},"content:0.index.md","/","","Home",[],"     cmd-bar.   powerful and flexible web component written in Vue.js.                                                                                                                      What's included      Vue compound components   Just import CmdBar and use all its children via a dot notation.    List virtualization   The list component, uses   useVirtualList | VueUse  under the hood, to render only the visible items.    Keybindings   A useKeyMap composable is provided, to handle keybindings with ease.    Unstyled   No CSS is included. You can style it as you want.    Extensible.   Cause of the way it's built, you can extend it as you want.    Examples.   You can find   multiple  examples of how to use it in the   examples folder .",{"id":12,"path":13,"dir":14,"title":15,"description":16,"keywords":17,"body":20},"content:1.introduction:1.getting-started.md","/introduction/getting-started","introduction","Getting Started","Setting up cmd-bar in you vue/nuxt application is only a couple of steps away.",[18,19],"Play online","Setup Vue","  Getting Started  Setting up cmd-bar in you vue/nuxt application is only a couple of steps away.  Play online  TODO: setup codesandbox/stackblitz\nYou can start playing with Docus in your browser using Stackblitz:  Play on StackBlitz  Setup Vue   Install   cmd-bar  dependency to your project:      npm   install   cmd-bar     yarn   add   cmd-bar    pnpm add cmd-bar\n   Then you can import the   CmdBar  Compound Component in your project.     import   { CmdBar }   from   'cmd-bar'    \u003C  CmdBar   :groups  =  \"groupedCommands\"  >     \u003C  CmdBar.Dialog  >       \u003C  template #header  >         \u003C  CmdBar.Input placeholder  =  \"search for anything /  >       \u003C/  template  >       \u003C  template #content  >         \u003C  CmdBar.List :config  =  \"listConfig\"  >             \u003C  template #  default=  \"{ command }\"  >               \u003C  div class  =  \"leading\"  >                 \u003C  img   :src  =  \"command.leading\"   alt  =  \"icon\"   />                 {{ command.label }}               \u003C/  div  >               \u003C  span v  -if=  \"command.shortcut\"   class  =  \"actions\"  >                 \u003C  kbd v  -  for  =  \"shortcut of command.shortcut)\"   :key  =  \"shortcut\"  >                   {{ shortcut }}                 \u003C/  kbd  >               \u003C/  span  >             \u003C/  template  >         \u003C/  CmdBar.List  >       \u003C/  template  >     \u003C/  CmdBar.Dialog  >   \u003C/  CmdBar  >  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"id":22,"path":23,"dir":14,"title":24,"description":25,"keywords":26,"body":28},"content:1.introduction:2.data-structure.md","/introduction/data-structure","Data Structure","Commands are represented as an array of Command objects. A Command object must at least have an id,label and action property. Here is an example:",[27],"Define your groups","  Data Structure  Commands are represented as an array of   Command  objects. A   Command  object must at least have an   id ,  label  and   action  property. Here is an example:     \u003C  script   setup   lang  =  \"ts\"  >   const   commands  :   Command  []   =   [     {       id:   '1'  ,       label:   'Command 1'  ,       action  : ()   =>   {         console.  log  (  'Command 1'  )       },     },     {       id:   '2'  ,       label:   'Command 2'  ,       action  : ()   =>   {}     },     {       id:   '3'  ,       label:   'Command 3'  ,       action  : ()   =>   {},     },   ]   \u003C/  script  >    \u003C  template  >     \u003C  CmdBar   :groups  =  \"[{key: 'people', commands: 'people'}]\"  >       \u003C  template   #  header  >         \u003C  CmdBar.Input   placeholder  =  \"search fo anything\"   />       \u003C/  template  >       \u003C  template   #  content  >         \u003C  CmdBar.List   :config  =  \"listConfig\"  >             {{ command.label }}         \u003C/  CmdBar.List  >       \u003C/  template  >     \u003C/  CmdBar  >   \u003C/  template  >  Define your groups  Commands are always grouped. You can define your groups by providing an array of   Group  objects to the   groups  prop. It must at least have a   key  and a   commands  property. Here is an example:     \u003C  script   setup   lang  =  \"ts\"  >   const   groups  :   Group  []   =   [     {       key:   'people'  ,       commands: [         {           id:   '1'  ,           label:   'Command 1'  ,         },         {           id:   '2'  ,           label:   'Command 2'  ,         },         {           id:   '3'  ,           label:   'Command 3'  ,         },       ],     },     {       key:   'places'  ,       commands: [         {           id:   '4'  ,           label:   'Command 4'  ,         },         {           id:   '5'  ,           label:   'Command 5'  ,         },         {           id:   '6'  ,           label:   'Command 6'  ,         },       ],     }   ]   \u003C/  script  >    \u003C  template  >   \u003C  CmdBar   :groups  =  \"groups\"  >       \u003C  template   #  header  >         \u003C  CmdBar.Input   placeholder  =  \"search fo anything\"   />       \u003C/  template  >       \u003C  template   #  content  >         \u003C  CmdBar.List   :config  =  \"listConfig\"  >           \u003C  template   #  default  =  \"  { command }  \"  >               {{ command.label }}           \u003C/  template  >         \u003C/  CmdBar.List  >       \u003C/  template  >     \u003C/  CmdBar  >   \u003C/  template  >  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"id":30,"path":31,"dir":14,"title":32,"description":7,"keywords":33,"body":34},"content:1.introduction:6.roadmap.md","/introduction/roadmap","Roadmap",[],"  Roadmap",{"id":36,"path":37,"dir":38,"title":39,"description":40,"keywords":41,"body":48},"content:2.api:1.components.md","/api/components","api","Components","Discover every provided component.",[42,43,44,45,46,47],"\u003CCmdBar />","\u003CCmdBar.Dialog />","\u003CCmdBar.Input />","\u003CCmdBar.Filter />","\u003CCmdBar.List />","\u003CCmdBar.Magnet />","  Components  Discover every provided component.   \u003CCmdBar />  Is the   main  component of this library. It is used to Provide the data to the other components. It takes the following props:    commands : An array of   Group  objects. (See   Group )   \u003CCmdBar.Dialog />  Uses the HTML   \u003Cdialog>  element to display the command bar. It takes the following props:    visible : Whether the command bar is visible or not. (Default:   false )  Inside the   CmdBar.Dialog  component, you can use the following slots:    header : The header of the dialog.   content : The content of the dialog.   footer : The footer of the dialog.   This is completely   optional , you can use your   own modal system . But if you want to use the built-in solution, which handles everything out of the box, you can use this component.   \u003CCmdBar.Input />  Provides an input to search through the commands. It takes the following props:    placeholder : The placeholder of the input. (Default:   Search for anything )   modelValue : The value of the input. (Default:   '' )    debounce : Debounce of the input. (Default:   300 )    fuseOptions : The fuse options of the input. (Default:   { includeMatches: true, keys: ['commands.label'] } )   \u003CCmdBar.Filter />  Built-in solution to filter the commands. It takes the following props:    defaultFilterOption : pre-selected filter option. If a key is provided, which is not in the   commands  array, it will be handled as an \"all\" filter. (Example: )   asCheckbox : Wether it should be possible to select multiple options or not. (Default:   false )   \u003CCmdBar.List />  To ensure great performance and scalability, the   CmdBarList  component uses   useVirtualList  under the hood, to render a virtualized list of commands.\nTo work properly, it needs some configuration passed via the   config  prop. Here is an example:     const   listConfig   =   {     /* The height of a single item, in Pixel. */     itemHeightInPixel: {       actions:   48  ,       users:   48     },     /* The height of the container, as a string with a unit of your choice. */     containerHeight:   '21rem'  ,     /* The height of a group label, in Pixel. */     groupLabelHeightInPixel:   20   }   The   itemHeightInPixel  can be an object, which contains the height of each group. Or it can be a number, which will be applied to all groups.  Inside the   CmdBar.List  component, you can use the following slots:    default : The default slot, which is used to render the items and provides the   command  object. (See   Command )   loading : The loading slot, which is used to render the loading state and provides the currently loading   group object. (See   Group )   \u003CCmdBar.Magnet />  WIP  A quick-actions container where you can drag&drop you most used commands, to access them quickly.\nKeep an eye on the   GitHub repository  for updates.  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"id":50,"path":51,"dir":38,"title":52,"description":53,"keywords":54,"body":57},"content:2.api:2.composables.md","/api/composables","Composables","Discover the composable functions provided by CmdBar.",[55,56],"defineCommands()","useKeymap()","  Composables  Discover the composable functions provided by CmdBar.   defineCommands()    defineCommands  ()  provides type safety for your commands. It takes an array of   Command  objects and returns an array of   Command  objects.     import   { defineCommands }   from   'cmd-bar'    return   data.value.users.  map  ((  user  :   Record  \u003C  string  ,   any  >)   =>     defineCommand  ({       id: user.id.  toString  (),       leading:   './src/assets/icons/user_new.svg'  ,       label:   `${  user  .  firstName  } ${  user  .  lastName  }`  ,       action  : ()   =>   {         // Define your action here.       }     })   )    useKeymap()    useKeymap()  let's you define your own key bindings with ease.   html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"id":59,"path":60,"dir":38,"title":61,"description":62,"keywords":63,"body":65},"content:2.api:3.styles.md","/api/styles","Styles","The cmd-baris completely unstyled. You can style it to your liking by using the style template provided by the CmdBar component.",[64],"Style Template","  Styles  The   cmd-bar is completely unstyled. You can style it to your liking by using the style template provided by the   CmdBar  component.   You can also check out the   examples  for some inspiration.  Style Template     .cmd-bar   {     &  __header   {       .input   {         &  ::placeholder   {         }       }       .filter   {         &  -chip   {         }         &  -chip--selected   {         }       }     }     &  __body   {       .list   {         &  __container   {         }         &  __items   {         }         &  __item   {         }       }       /* loading element*/       .skeleton   {       }       /* empty list | Tip: position absolute to prevent jumping of container  */       .empty   {       }     }     &  __footer   {     }      /* keyboard shortcut */     .kbd   {     }      /* Animations */   }  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"id":67,"path":68,"dir":38,"title":69,"description":70,"keywords":71,"body":73},"content:2.api:4.keybindings.md","/api/keybindings","Keybindings","To make your application more accessible, you can use the useKeymap() composable to define your own key bindings.",[56,72],"Command Shortcut","  Keybindings  To make your application more accessible, you can use the   useKeymap()  composable to define your own key bindings.  To   bind a key to a command , you can use the   shortcut  property of the   Command  object.  Some   default  key bindings are already defined:    ArrowUp : Select the previous item in the list.   ArrowDown : Select the next item in the list.   Enter : Execute the selected item.   useKeymap()   useKeymap()  let's you define your own key bindings with ease.  You can just pass an object with the following structure:     useKeymap  ((  nav  )   =>   {     return   [       {         key:   'ArrowRight'  ,         action  : ()   =>   nav.  prev  (),         override:   true  ,         autoRepeat:   true          },       {         key:   'ArrowLeft'  ,         action  : ()   =>   nav.  next  (),         override:   true  ,         autoRepeat:   true       }     ]   })   The properties   override  and   autoRepeat  are optional, and both default to   false .  The composable also gives you access to the   nav  object, which provides the following methods:    prev() : Select the previous item in the list.   next() : Select the next item in the list.   execute() : Execute the selected item.   Command Shortcut  You can also define a shortcut for a command by using the   shortcut  property of the   Command  object.     const   actions   =   [     {       id:   'new-resource'  ,       label:   'Create new Resource'  ,       leading:   './src/assets/icons/create.svg'  ,       action  : ()   =>   alert  (  'New Resource created'  ),       shortcut:   'Ctrl+R'     },     {       id:   'new-service'  ,       label:   'Add new Service'  ,       leading:   './src/assets/icons/service_1.svg'  ,       action  : ()   =>   alert  (  'New Service added'  ),       shortcut:   'Ctrl+S'     },   ]   Keybindings are internally handled by   useMagicKeys | VueUse . If you have any questions about the syntax, please refer to their documentation.  html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",1700821655978]